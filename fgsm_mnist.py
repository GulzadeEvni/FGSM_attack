# -*- coding: utf-8 -*-
"""FGSM_mnist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Igochn6ZDPbllKMYK32E2BpA9ADeC8yZ
"""

import tensorflow as tf
import matplotlib.pyplot as plt

import tensorflow as tf
import matplotlib.pyplot as plt

# Load MNIST dataset
mnist = tf.keras.datasets.mnist
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()
train_images, test_images = train_images / 255.0, test_images / 255.0

# Define a simple CNN model
model = tf.keras.Sequential([
    tf.keras.layers.Reshape((28, 28, 1), input_shape=(28, 28)),
    tf.keras.layers.Conv2D(32, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D((2, 2)),
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D((2, 2)),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(10)
])

# Compile the model
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

# Train the model
model.fit(train_images, train_labels, epochs=5, validation_data=(test_images, test_labels))

def display_images_with_predictions(image, description, predictions):
    plt.figure()
    plt.imshow(image, cmap='gray')
    plt.title(f'{description}\nPredicted Label: {predictions[0]}, Confidence: {predictions[1]:.2f}')
    plt.axis('off')
    plt.show()

# Get a sample image from the test set
image_index = 2  # You can change this to any index in the test set
sample_image = test_images[image_index]

# Convert the sample image to a TensorFlow tensor
sample_image_tensor = tf.convert_to_tensor(sample_image[None, ...], dtype=tf.float32)

# Display the original image
original_predictions = model.predict(sample_image_tensor)
original_label = tf.argmax(original_predictions, axis=1)
original_confidence = tf.nn.softmax(original_predictions)[0, original_label[0]]
display_images_with_predictions(sample_image, 'Original Image', (original_label.numpy()[0], original_confidence.numpy()))

# Helper function to create adversarial pattern
def create_adversarial_pattern(input_image, input_label):
    with tf.GradientTape() as tape:
        tape.watch(input_image)
        prediction = model(input_image)
        loss = tf.keras.losses.sparse_categorical_crossentropy(input_label, prediction)

    gradient = tape.gradient(loss, input_image)
    signed_grad = tf.sign(gradient)
    return signed_grad

# Define the target label to trick the model
target_label = 3  # You can change this to any other label

# Get the input label of the image
input_label = tf.constant([test_labels[image_index]])

# Create adversarial perturbations
perturbations = create_adversarial_pattern(sample_image_tensor, input_label)

# Generate adversarial examples
epsilons = [0, 0.03, 0.06, 0.1, 0.15,0.5]

for epsilon in epsilons:
    adv_x = sample_image + epsilon * perturbations.numpy()[0]
    adv_x = tf.clip_by_value(adv_x, 0, 1)

    # Get predictions for adversarial images
    adv_predictions = model.predict(adv_x[None, ...])
    adv_label = tf.argmax(adv_predictions, axis=1)
    adv_confidence = tf.nn.softmax(adv_predictions)[0, adv_label[0]]

    display_images_with_predictions(adv_x, f'Adversarial Image (Epsilon={epsilon})', (adv_label.numpy()[0], adv_confidence.numpy()))

"""**********************************************************************************************"""